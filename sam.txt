End-to-End Story 
Initially, DevOps sets up the SAM template and CI/CD pipeline and deploys the base infrastructure. After that, the SAM template lives with the application code. Developers update Lambda code and configuration, and on every commit, the pipeline builds the app, creates a CloudFormation change set, and deploys it. My role is to ensure the pipeline, IAM, and deployment strategy work reliably.
Dev writes code, DevOps builds the road.

âœ… Step 1: Initial Infrastructure Setup

	DevOps / Platform team creates:
	SAM template (template.yaml)
	CI/CD pipeline (CodePipeline + CodeBuild + CloudFormation)

	Run:
	cd ~/environment/
	sam init --runtime python3.12 ()
	cd ./sam-app
	sam build
	sam local invoke HelloWorldFunction --event events/event.json
	curl  http://127.0.0.1:8000/
	labBucket=lab4-sam-[YOUR-INITIALS]-[YOUR-POSTAL-CODE]
	aws s3 mb s3://$labBucket
	sam package --output-template-file packaged.yaml --s3-bucket $labBucket
	sam deploy --template-file packaged.yaml --stack-name sam-app --capabilities CAPABILITY_IAM
	aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[].Outputs[?OutputKey==`HelloWorldApi`]' --output table
	check CREATE_COMPLETE in management console

	ğŸ“Œ Purpose:
	Create baseline infrastructure
	Validate template
	Create first CloudFormation stack

âœ… Step 2: Template Ownership & Development

	The SAM template is part of the application repo
	Dev team:
	Modifies Lambda code
	Updates runtime (Node.js, Python, etc.)
	May adjust function config (memory, timeout)
	They DO NOT touch pipeline logic

	ğŸ“Œ Important:
	Devs change application, not platform

âœ… Step 3: Code Commit Triggers Pipeline

	Developer commits code to Git (CodeCommit / GitHub)
	CodePipeline is triggered automatically

âœ… Step 4: Build Stage (SAM Packaging)

	CodeBuild runs:
	sam build
	aws cloudformation package

	ğŸ“Œ Purpose:
	Upload Lambda artifacts to S3
	Generate outputtemplate.yaml

âœ… Step 5: Change Set Creation

	Pipeline creates a CloudFormation Change Set
	Change set shows:
	What will change
	Which resources are updated/replaced

	ğŸ“Œ This is safe deployment planning

âœ… Step 6: Change Set Execution

	Change set is executed (auto or manual approval)
	CloudFormation updates stack

	ğŸ“Œ If DeploymentPreference exists:
	CodeDeploy handles traffic shifting
	Canary / Linear deployment happens

âœ… Step 7: DevOps Responsibility (Your Role)

	You DO NOT deploy code manually every time.
	You ensure:
	SAM template standards
	Pipeline reliability
	IAM permissions
	Rollback & alarms
	Environment consistency


AWS SAM â€“ Basics
Q1. What is AWS SAM?
Answer:
	AWS Serverless Application Model (SAM) is an extension of AWS CloudFormation that simplifies building, testing, and deploying serverless applications using Lambda, API Gateway, and related services.

Q2. Why do we use AWS SAM instead of plain CloudFormation?
Answer:
	SAM provides simplified syntax, built-in best practices, local testing (sam local), and native support for CI/CD and traffic shifting, which reduces boilerplate CloudFormation code.

Q3. What does sam init do?
Answer:
	sam init initializes a serverless project by creating a predefined project structure, sample Lambda code, SAM template, and configuration files.

Q4. What is the purpose of sam build?
Answer:
	sam build resolves dependencies, packages Lambda code, and prepares deployment artifacts inside the .aws-sam/build directory.

Q5. How do you test a SAM application locally?
Answer:
	Using:
	sam local invoke to test a Lambda function
	sam local start-api to simulate API Gateway locally using Docker
	Local Testing & API Gateway

Q8. Why is an S3 bucket required for SAM deployment?
Answer:
	Lambda deployment packages must be uploaded to S3 so CloudFormation can reference them during stack creation.

Q9. What does sam package do?
Answer:
	It uploads Lambda artifacts to S3 and generates a transformed CloudFormation template (packaged.yaml) with S3 references.

Q10. What happens when you run sam deploy?
Answer:
	It creates or updates a CloudFormation stack that provisions Lambda, API Gateway, IAM roles, and other resources.


Q11. Is SAM deployment backed by CloudFormation?
Answer:
	Yes. SAM is a CloudFormation transform, and every SAM deployment results in a CloudFormation stack.

Q12. What are CloudFormation Outputs used for?
Answer:
	Outputs expose important values like API Gateway URLs, Lambda ARNs, and IAM role ARNs after stack creation.

CI/CD Pipeline (CodePipeline)
Q13. What services are used in the CI/CD pipeline?
Answer:
	CodeCommit â€“ Source control
	CodeBuild â€“ Build & package SAM template
	CloudFormation â€“ Deploy infrastructure
	CodeDeploy â€“ Traffic shifting deployment

Q14. What triggers the pipeline execution?
Answer:
	Any code change pushed to the CodeCommit repository triggers the pipeline automatically.

Q15. What is the role of buildspec.yml?
Answer:
	It defines the build steps for CodeBuild, including packaging the SAM template and uploading artifacts to S3.

Q16. Why was the S3 bucket name added to buildspec.yml?
Answer:
	So CodeBuild knows where to upload packaged Lambda artifacts during the build phase.

Change Sets & Deployment
Q17. Why does the pipeline create a CloudFormation Change Set?
Answer:
	Change Sets allow previewing infrastructure changes before execution, ensuring safer deployments.

Q18. How is the Change Set executed automatically?
Answer:
	A second CloudFormation action (Execute a change set) is added in the Deploy stage of CodePipeline.

Q19. Can Change Sets be executed via CLI?
Answer:
	Yes, using:
	aws cloudformation execute-change-set
	But in this lab, execution is automated via CodePipeline.

Traffic Shifting & Blue-Green Deployment
Q20. What is traffic shifting?
Answer:
	Traffic shifting gradually routes user traffic from the old Lambda version to the new version instead of switching instantly.

Q21. Why is traffic shifting important?
Answer:
	It reduces risk, enables quick rollback, and minimizes customer impact during deployments.

Q22. Which AWS service manages traffic shifting in this lab?
Answer:
	AWS CodeDeploy manages Lambda traffic shifting using weighted aliases.

Q23. What deployment strategy is used here?
Answer:
	Blue-Green deployment with gradual traffic shifting.

Q24. How do you observe traffic shifting?
Answer:
	By refreshing the application URL and observing alternating blue and green responses during deployment.

Q25. What happens if the deployment fails midway?
Answer:
	CodeDeploy automatically rolls back traffic to the previous stable Lambda version.

Versioning & Re-deployment
Q26. What caused the second deployment to trigger?
Answer:
	A code change (lab4a.html â†’ lab4b.html) pushed to CodeCommit triggered the pipeline.

Q27. Does traffic shifting apply to EC2 deployments as well?
Answer:
	Yes, but via load balancers. In Lambda, traffic shifting uses aliases and versions.


1ï¸âƒ£ Your case (clear statement)

You have:
Node.js application
Returns an HTML test page
Deployed using SAM
Runs on AWS Lambda
Triggered via API Gateway

ğŸ‘‰ This is still a serverless application
ğŸ‘‰ No EC2, no web server, no Apache/Nginx

So the deployment model does NOT change.

2ï¸âƒ£ Where does the HTML actually live?
â— Important truth
The HTML file does NOT live in AWS like a website folder
It lives inside your Node.js Lambda package.
Example structure:

project/
â”œâ”€â”€ template.yaml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app.js
â”‚   â””â”€â”€ index.html

3ï¸âƒ£ How Lambda serves the HTML
Example Node.js Lambda code
const fs = require('fs');
const path = require('path');

exports.handler = async () => {
  const html = fs.readFileSync(
    path.join(__dirname, 'index.html'),
    'utf8'
  );

  return {
    statusCode: 200,
    headers: { 'Content-Type': 'text/html' },
    body: html
  };
};


ğŸ“Œ What this means:

index.html is bundled inside the Lambda zip
Lambda reads the file
Returns it via API Gateway

ğŸ‘‰ No server
ğŸ‘‰ No public filesystem
ğŸ‘‰ No appspec.yml

4ï¸âƒ£ How this HTML reaches AWS
CI/CD flow (simplified)
Developer commits code
      â†“
CodePipeline triggered
      â†“
CodeBuild runs sam build
      â†“
Lambda zip created (Node.js + HTML)
      â†“
sam deploy
      â†“
Lambda updated


ğŸ“Œ The .html file becomes part of:

Lambda deployment package
Stored internally in Lambda service

5ï¸âƒ£ Why appspec.yml is NOT needed (again, very important)
Reason	Explanation
No server	Lambda is managed
No file copy	AWS handles deployment
No service restart	Lambda versions
Traffic control	Lambda alias

So:
âŒ No appspec.yml
âŒ No shell scripts
âŒ No lifecycle hooks

6ï¸âƒ£ Traffic splitting in YOUR Node.js + HTML case
What actually happens
User request
   â†“
API Gateway
   â†“
Lambda Alias (live)
   â†“
10% â†’ New Lambda version
90% â†’ Old Lambda version


ğŸ“Œ Both versions exist temporarily
ğŸ“Œ HTML file is also versioned

7ï¸âƒ£ When is old infrastructure deleted?
Automatically by AWS ğŸ¯

After traffic reaches 100%

After bake time

If deployment succeeds

ğŸ‘‰ Old Lambda version is:

No longer referenced by alias

Eventually garbage-collected

You do nothing manually

8ï¸âƒ£ Final corrected â€œoverall storyâ€ âœ…

Here is your corrected version (interview-ready):

â€œWe first deploy the base infrastructure using sam deploy. The SAM template is then shared with the development team. Developers make application changes like updating Node.js logic or HTML files and commit the code. When they commit, the pipeline triggers, runs sam build and sam deploy. SAM creates a CloudFormation change set and deploys only the changes. Traffic splitting is handled using Lambda aliases. As a DevOps engineer, my responsibility is to manage SAM builds, the pipeline, and IAMâ€”not application code.â€

9ï¸âƒ£ One-line memory rule ğŸ§ 
Node.js + HTML on Lambda â†’ HTML lives inside Lambda zip


If you want next, I can explain:

ğŸ”¥ Exact AWS resources created for this Node.js app

ğŸ§ª Rollback scenario during canary

ğŸ“¦ Lambda zip structure in detail

ğŸ¯ How to explain this in an interview in 30 seconds

Just tell me ğŸ‘

steps

aws sso login
aws-vault exec kunalshrivastava1 --duration=8h
cd "C:\kunal\cloudthat training devops\scope\aws sam"
rmdir .\sam-app\
sam init --runtime python3.11
cd .\sam-app\
aws s3 mb s3://lab4-sam-ks-411045
sam build
sam local invoke HelloWorldFunction --event events/event.json
sam local start-api -p 8000
Open the sam-app/samconfig.toml.
In the [default.package.parameters] section, change resolve_s3 = true to resolve_s3 = false
sam package --output-template-file packaged.yaml --s3-bucket samapp-sam-ks-411045
sam deploy --template-file packaged.yaml --stack-name sam-app --capabilities CAPABILITY_IAM
aws cloudformation describe-stacks --stack-name sam-app --query 'Stacks[].Outputs[?OutputKey==`HelloWorldApi`]' --output table
cd "C:\kunal\cloudthat training devops\scope\aws sam\sam-app"
git init
git status
git commit -m "Initial commit"
git config --global user.name "Kunal"
git config --global user.email "kunal@example.com"
git push
create code pipeline
---

## Task 2.2: Create CodePipeline for lab4 application
1. Open **AWS Console â†’ CodePipeline â†’ Create pipeline**
2. Choose **Build custom pipeline â†’ Next**
### Pipeline settings
3. Pipeline name: `lab4-sam-pipeline`
4. Service role: **Existing service role**
5. Role ARN: `AWSCodePipelineServiceRole-AWS_REGION-lab4-sam-pipeline`
6. Choose **Next**
### Source stage
7. Source provider: **AWS CodeCommit**
8. Repository name: `lab4-app`
9. Branch name: `main`
10. Output format: **CodePipeline default**
11. Choose **Next**
### Build stage
12. Build provider: **AWS CodeBuild**
13. Project name: **Create project**
14. Project name: `lab4-sam-build`
15. Environment:

    * Image: **Managed**
    * OS: **Ubuntu**
    * Runtime: **Standard**
    * Image: `aws/codebuild/standard:7.0`
    * Image version: **Always use latest**
16. Service role: **Existing service role**
17. Role: `CodeBuild_Service_Role`
18. Buildspec: **Use buildspec file**
19. Choose **Continue to CodePipeline**
20. Region: same as `AwsRegionCode`
21. Choose **Next**
### Test stage
22. Choose **Skip test stage**
### Deploy stage (Create change set)
23. Deploy provider: **AWS CloudFormation**
24. Region: same as `AwsRegionCode`
25. Action mode: **Create or replace a change set**
26. Stack name: `sam-app`
27. Change set name: `lab4-sam-changeset`
28. Artifact name: `BuildArtifact`
29. File name: `outputtemplate.yaml`
30. Capabilities: `CAPABILITY_IAM`
31. Role name: `SAM_Role`
32. Choose **Next**
### Create pipeline
33. Review â†’ **Create pipeline**
34. Choose **Stop execution â†’ Stop and abandon**
---
## Add Execute Change Set action
35. Open pipeline â†’ **Edit**
36. Edit **Deploy stage**
37. Click **+ Add action group** (at bottom)
38. Action name: `deploy-changeset`
39. Provider: **AWS CloudFormation**
40. Input artifact: `BuildArtifact`
41. Action mode: **Execute a change set**
42. Stack name: `sam-app`
43. Change set name: `lab4-sam-changeset`
44. Choose **Done â†’ Save**
---
## Run pipeline
45. Choose **Release change â†’ Release**
46. Verify all stages show **Succeeded**









